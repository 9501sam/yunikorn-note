# 0520

```go
func (cc *ClusterContext) handleRMUpdateApplicationEvent(event *rmevent.RMUpdateApplicationEvent) {
	request := event.Request
	if len(request.New) == 0 && len(request.Remove) == 0 {
		return
	}
	acceptedApps := make([]*si.AcceptedApplication, 0)
	rejectedApps := make([]*si.RejectedApplication, 0)

	for _, app := range request.New {  // what is request.New
        ...
	}
}
```

```rmevent.RMUpdateApplicationEvent```:
```go
// Incoming UpdateApplication events from the RM to the scheduler (async)
type RMUpdateApplicationEvent struct {
	// The generic UpdateApplication does not wait for a result,
	// results are communicated back via the outgoing events.
	Request *si.ApplicationRequest
}
```

```si.ApplicationRequest```:
```go
type ApplicationRequest struct {
	// RM should explicitly add application when allocation request also explictly belongs to application.
	// This is optional if allocation request doesn't belong to a application. (Independent allocation)
	New []*AddApplicationRequest `protobuf:"bytes,1,rep,name=new,proto3" json:"new,omitempty"`  // this is the event.Request 
	// RM can also remove applications, all allocation/allocation requests associated with the application will be removed
	Remove []*RemoveApplicationRequest `protobuf:"bytes,2,rep,name=remove,proto3" json:"remove,omitempty"`
	// ID of RM, this will be used to identify which RM of the request comes from.
	RmID                 string   `protobuf:"bytes,3,opt,name=rmID,proto3" json:"rmID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}
```

```AddApplicationRequest```:
```go
type AddApplicationRequest struct {
	// The ID of the application, must be unique
	ApplicationID string `protobuf:"bytes,1,opt,name=applicationID,proto3" json:"applicationID,omitempty"`
	// The queue this application is requesting. The scheduler will place the application into a
	// queue according to policy, taking into account the requested queue as per the policy.
	QueueName string `protobuf:"bytes,2,opt,name=queueName,proto3" json:"queueName,omitempty"`
	// The partition the application belongs to
	PartitionName string `protobuf:"bytes,3,opt,name=partitionName,proto3" json:"partitionName,omitempty"`
	// The user group information of the application owner
	Ugi *UserGroupInformation `protobuf:"bytes,4,opt,name=ugi,proto3" json:"ugi,omitempty"`
	// A set of tags for the application. These tags provide application level generic inforamtion.
	// The tags are optional and are used in placing an appliction or scheduling.
	// Application tags are not considered when processing AllocationAsks.
	Tags map[string]string `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Execution timeout: How long this application can be in a running state
	// 0 or negative value means never expire.
	ExecutionTimeoutMilliSeconds int64 `protobuf:"varint,6,opt,name=executionTimeoutMilliSeconds,proto3" json:"executionTimeoutMilliSeconds,omitempty"`
	// The total amount of resources gang placeholders will request
	PlaceholderAsk *Resource `protobuf:"bytes,7,opt,name=placeholderAsk,proto3" json:"placeholderAsk,omitempty"`
	// Gang scheduling style can be hard (the application will fail after placeholder timeout)
	// or soft (after the timeout the application will be scheduled as a normal application)
	GangSchedulingStyle  string   `protobuf:"bytes,8,opt,name=gangSchedulingStyle,proto3" json:"gangSchedulingStyle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}
```
* in log:
```
&
{
    Request: 
        new: < 
            applicationID: "nginx_2019_01_22_00001"
            queueName: "root.sandbox"
            partitionName: "[mycluster]default"
            ugi: < user: "nobody" > 
            tags: < key: "namespace" value: "yunikorn" > 
            tags: < key: "yunikorn.apache.org/schedulingPolicyParameters" value: "" > 
            tags: < key: "yunikorn.apache.org/task-groups" value: "" > 
            gangSchedulingStyle: "Soft" 
        > 
        rmID: "mycluster"
}
```

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: nginx
  name: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
        applicationId: "nginx_2019_01_22_00001"
        queue: root.sandbox
      name: nginx
    spec:
      schedulerName: yunikorn
      containers:
        - name: nginx
          image: "nginx:1.11.1-alpine"
          resources:
            requests:       # 想抓取 request 的資訊
              cpu: "500m"
              memory: "1024M"
```
https://github.com/apache/yunikorn-core/blob/a590b7d0059cc875bc9ba5c81451a3db14c54326/pkg/scheduler/objects/application.go#L106  
```NewApplication```
```go
func NewApplication(siApp *si.AddApplicationRequest, ugi security.UserGroup, eventHandler handler.EventHandler, rmID string) *Application {
	app := &Application{
		ApplicationID:        siApp.ApplicationID,
		Partition:            siApp.PartitionName,
		SubmissionTime:       time.Now(),
		queuePath:            siApp.QueueName,
		tags:                 siApp.Tags,
		pending:              resources.NewResource(),
		allocatedResource:    resources.NewResource(),
		maxAllocatedResource: resources.NewResource(),
		allocatedPlaceholder: resources.NewResource(),
		requests:             make(map[string]*AllocationAsk),
		reservations:         make(map[string]*reservation),
		allocations:          make(map[string]*Allocation),
		stateMachine:         NewAppState(),
		placeholderAsk:       resources.NewResourceFromProto(siApp.PlaceholderAsk),
		finishedTime:         time.Time{},
		rejectedMessage:      "",
		stateLog:             make([]*StateLogEntry, 0),
	}
	placeholderTimeout := common.ConvertSITimeoutWithAdjustment(siApp, defaultPlaceholderTimeout)
	gangSchedStyle := siApp.GetGangSchedulingStyle()
	if gangSchedStyle != Soft && gangSchedStyle != Hard {
		log.Logger().Info("Unknown gang scheduling style, using soft style as default",
			zap.String("gang scheduling style", gangSchedStyle))
		gangSchedStyle = Soft
	}
	app.gangSchedulingStyle = gangSchedStyle
	app.execTimeout = placeholderTimeout
	if app.GetTag(AppTagStateAwareDisable) != "" {
		app.startTimeout = 0 // transition immediately to Running
	} else {
		app.startTimeout = startingTimeout
	}
	app.user = ugi
	app.rmEventHandler = eventHandler
	app.rmID = rmID
	return app
}
```
